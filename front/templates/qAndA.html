<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>offer之路</title>
    <script src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-1.8.0.js"></script>
    <meta name="viewport" content="initial-scale=1, maximum-scale=1">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="stylesheet" href="//g.alicdn.com/msui/sm/0.6.2/css/sm.min.css">
    <link rel="stylesheet" href="//g.alicdn.com/msui/sm/0.6.2/css/sm-extend.min.css">
</head>

<script>
    function today_question() {
        var arr = [
            '阻塞队列是什么，有哪些？',
            'synchronized作用,语法，原理，特性,锁优化',
            'Synchronized和Lock有什么区别？',
            '线程池是什么？优势在于哪里？',
            '获得线程的几种方法',
            '几种常见的线程池？',
            '线程池的几个参数',
            '线程池底层工作原理',
            '线程池的拒绝策略',
            '你在工作中单一的、固定数的和可,变的三种创建线程池的方法，你用哪个多，超级大坑',
        '合理配置线程池你是如果考虑的？'
        ];
        var arr2 = [
'阻塞队列是一个队列，具由当队列为空的时候取操作被阻塞，当队列为满的时候存操作被阻塞。\n' +
'ArrayBlockingQueue ：基于数组的阻塞队列，按照先进先出的顺序进行排序\n' +
'LinkedBlockingQueue：基于链表的阻塞队列，按照先进先出的顺序进行排序，吞吐量大于ArrayBlockingQueue\n' +
'SynchronousQueue：是一个不存储元素的阻塞队列，每个插入操作都必须等另一个线程移除调用操作，否则插入操作一直处于阻塞状态，吞吐量大 LinkedBlockingQueue。\n' +
'SynchronousQueue，实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移出队列。',
            'Synchronized 的作用主要有三个：\n' +
            '确保线程互斥的访问同步代码\n' +
            '保证共享变量的修改能够及时可见\n' +
            '有效解决重排序问题 \n' +
            '从语法上讲，Synchronized 总共有三种用法：\n' +
            '修饰普通方法\n' +
            '修饰静态方法\n' +
            '修饰代码块\n' +
            'Synchronized 的实现原理：\n' +
            'Synchronized 的语义底层是通过一个 Monitor 的对象来完成，\n' +
            '每个对象有一个监视器锁（Monitor），当 Monitor 被占用时就会处于锁定状态。\n' +
            '线程执行 Monitorenter 指令时尝试获取 Monitor 的所有权，过程如下：\n' +
            '如果 Monitor 的进入数为 0，则该线程进入 Monitor，然后将进入数设置为 1，该线程即为 Monitor 的所有者。\n' +
            '如果线程已经占有该 Monitor，只是重新进入，则进入 Monitor 的进入数加 1。\n' +
            '如果其他线程已经占用了 Monitor，则该线程进入阻塞状态，直到 Monitor 的进入数为 0，再重新尝试获取 Monitor 的所有权。\n' +
            '\n' +
            '执行 Monitorexit 的线程必须是 Objectref 所对应的 Monitor 的所有者。\n' +
            '指令执行时，Monitor 的进入数减 1，如果减 1 后进入数为 0，那线程退出 Monitor，不再是这个 Monitor 的所有者\n' +
            'synchronized与原子性\n' +
            '原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行\n' +
            '在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。前面中，介绍过，这两个字节码指令，在Java中对应的关键字就是synchronized。\n' +
            '通过monitorenter和monitorexit指令，可以保证被synchronized修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。\n' +
            'synchronized与可见性\n' +
            '被synchronized修饰的代码，在开始执行时会加锁，执行完成后会进行解锁。而为了保证可见性，有一条规则是这样的：对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。\n' +
            '所以，synchronized关键字锁住的对象，其值是具有可见性的。\n' +
            'synchronized与有序性\n' +
            '有序性即程序执行的顺序按照代码的先后顺序执行。\n' +
            'Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有操作都是天然有序的。如果在一个线程中观察另一个线程，所有操作都是无序的。\n' +
            '以上这句话也是《深入理解Java虚拟机》中的原句，但是怎么理解呢？作者并没有详细的解释。我另外查的资料，意思就是这其实和as-if-serial语义有关。\n' +
            'as-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守as-if-serial语义。\n' +
            '简单说就是，as-if-serial语义保证了单线程中，指令重排是有一定的限制的，而只要编译器和处理器都遵守了这个语义，那么就可以认为单线程程序是按照顺序执行的。当然，实际上还是有重排的，只不过我们无须关心这种重排的干扰。\n' +
            '所以呢，由于synchronized修饰的代码，同一时间只能被同一线程访问。那么也就是单线程执行的。所以，可以保证其有序性。\n' +
            'synchronized与锁优化\n' +
            '在jdk1.6中对锁的实现引入了大量的优化，如锁粗化（Lock Coarsening）、锁消除（Lock Elimination）、轻量级锁（Lightweight Locking）、 偏向锁（Biased Locking）、适应性自旋（Adaptive Spinning）等技术来减少锁操作的开销。\n' +
            '就比如\n' +
            '锁粗化(Lock Coarsening) 减少不必要的紧连在一起的unlock,lock操作，将多个连续的锁扩展成一个范围更大的锁\n' +
            '\n' +
            '轻量级锁 (Lightweight Locking) 这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态（即单线程执行环境），在无锁竞争的情况下完全可以避免调用操作系统层面的重量级互斥锁，取而代之的是在monitorenter和monitorexit中只需要依靠一条CAS原子指令就可以完成锁的获取及释放。当存在锁竞争的情况下，执行CAS指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒',

            '1，原始结构\n' +
            'Synchronized是JVM层面上的锁，底层是monitor对象，像wait/notify也都是依赖monitor对象在同步代码块或者同步方法中完成的\n' +
            'Lock是JDK层面上的实现\n' +
            '2，使用方法\n' +
            'Synchronized不需要用户手动去释放锁，在线程执行完之后，系统会自动去释放\n' +
            'Lock是需要用户手动去释放锁，否则会造成死锁现象，lock/unlock需要配合try/catch使用\n' +
            '3，等待是否可中断\n' +
            'Synchronized是不可中断的，除非抛出异常或者正常执行完成\n' +
            'Lock可以配合调用一些方法，用TryLock设置超时方法，调用interrupt设置中断线程\n' +
            '4，加锁是否公平\n' +
            'Synchronized默认是非公平锁\n' +
            'Lock默认也是非公平锁，但是可以传入Boolean，True的话就是公平锁，False就是非公平锁\n' +
            '5，锁可以绑定多个Condition\n' +
            'Synchronized可以实现需要分组唤醒的线程，不像Synchronized要么随机唤醒一个，要么唤醒全部',

            '线程池是在多线程运行的环境下，用来控制线程执行数量的一种手段，它的处理过程是，把要执行的任务放到自己的队列中，当创建线程后启动该任务，如果线程数量超过了最大数量，那么就等待，等其他线程执行完任务后，再从队列中取出任务执行。\n' +
            '主要特点就是：控制线程并发数量，管理线程，线程复用\n' +
            '优势在于：降低资源消耗，可重复利用已经创建的线程避免线程多次创建带来的资源消耗；提高响应速度，任务即将执行的时候不需要等待线程创建；提高线程的可管理性，线程是稀缺资源，无限制的创建消费，容易导致系统资源的消耗，和系统的不稳定性，使用线程池可以做到统一调配，统一监控。',
        '1，继承Thread  \n' +
        '2，实现runnable \n' +
        '3，实现callable\n' +
        '4，使用线程池',
        '线程池的底层就是ThreadPoolExecutor\n' +
        '\n' +
        'Executors.newFixedThreadPool(int) \n' +
        '创建一个定长的线程池，可控制线程的最大并发数量，超出的数量将会在队列中等待。用于执行长期任务，性能很好。\n' +
        'Executors.newSingleThreadExecutor() \n' +
        '创建一个单线程化的线程池，保证所有任务都是按照顺序执行的。用于一个任务一个任务的执行场景。\n' +
        'Executors.newCachedThreadThreadPool() \n' +
        '创建一个可缓存的线程池，如果线程超出过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。用于执行很多短期异步的小程序或者负载较轻的服务器',
        'corePoolSize：线程池中常驻核心线程\n' +
        'maximumPoolSize ：线程池中最大可以容纳的线程池数量\n' +
        'keepAliveTime：除核心线程以外其他线程可以保留的最大时间\n' +
        'unit：keepAliveTime的单位\n' +
        'workQueue：任务队列，提交但是还没被执行的任务存放的队列\n' +
        'threadFactory：用于生成线程池的线程工厂，用于创建线程，一般用于默认的就可以\n' +
        'handler：拒绝策略，表示队列满了并且工作线程大于等于线程池的最大线程时，如何拒绝任务。',

        '1，创建线程池之后，等待提交过来的任务请求\n' +
        '2，当调用execute()方法添加一个请求任务的时候，线程池会做以下判断\n' +
        '    2.1，如果正在运行的线程数小于corePoolSiez，那么立马创建这个线程\n' +
        '    2.2，若果正在运行的线程数量大于等于corePollSize，那么将这个任务放入队列\n' +
        '    2.3，如果这个时候队列满了且线程数量小于maximumPollSize，那么立即创建非核心线程去执行这个任务\n' +
        '    2.4，如果队列满了且正在运行的线程数量大于等于maximumPollSize，那么线程池会启动饱和拒绝策略来执行\n' +
        '3，当一个线程完成任务的时候，它会从队列中取出下一个任务来执行。\n' +
        '4，当一个线程无所事事超出了一定的时间（keepAliveTime），线程池会判断：\n' +
        '    如果当前线程数大于corePollSize那么这个线程会被停掉，所以线程的所有任务完成后他的线程数量会被缩小为corePollSize',

        '等待队列满了，线程池中也达到了最大的任务线程数，无法继续为新的任务提供新的服务。\n' +
        'AbortPolicy：处理程序遭到拒绝，抛出rejectedExecutionException\n' +
        'CallerRunsPolicy：线程调用运行该任务execute本身，此策略提供简单的反馈控制机制，能够减缓新任务的提交速度\n' +
        'DiscardPolicy：不能执行的任务被删除\n' +
        'DiscardOldPolicy：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试7执行任务（还是失败的话，就继续重复操作）',

        'java的BlockingQueue有ArrayBlockingQueue和LinkedBlockingQueue\n' +
        '\n' +
        'ArrayBlockingQueue是一种用数组实现的有界的阻塞队列，必须设置容量\n' +
        '\n' +
        'LinkedBlockingQueue是一种用链表来实现的有界的阻塞队列，可以设置容量，也可以不设置，一旦不设置容量，就是一个无边界的阻塞队列，默认容量Integer.Max_Value\n' +
        '\n' +
        '而NewThreadPoll创建的时候没有指定LinkedBlockingQueue的容量，就是说此时，可以有无限的任务被加入到这个队列中，所以容易产内存溢出的问题\n' +
        '\n' +
        'newFixedThreadPool和newSingleThreadExecutor两个工厂方法上，并不是说newCachedThreadPool和newScheduledThreadPool这两个方法就安全了，这两种方式创建的最大线程数可能是Integer.MAX_VALUE，而创建这么多线程，必然就有可能导致OOM。',

        'CPU密集型：\n' +
        'CPU密集型是该任务需要大量的运算，CPU不停歇的工作\n' +
        '那么就应该尽量少的线程数量，一般为CPU的核数+1\n' +
        'IO密集型：\n' +
        '由于IO密集型不是一直处于工作状态，所以可多分配一点 cpu核数*2\n' +
        '也可以使用公式：CPU 核数 / (1 - 阻塞系数)；其中阻塞系数在 0.8 ～ 0.9 之间。'];
        var index = Math.floor((Math.random() * arr.length));
        $("#question").text(arr[index]);
        $("#answer").text(arr2[index]);
        $("#question-card").removeAttr("style");
        $("#answer-card").attr("style", "display:none")
    }

    function yesterday_question() {
        var arr = ['什么是fail-fast？什么是fail-safe？',
        '什么是CopyOnWrite？',
            'MySQL 5.6中，对索引做了哪些优化吗？',
        ];
        var arr2 = ['我们通常说的Java中的fail-fast机制，默认指的是Java集合的一种错误检测机制。当多个线程对部分集合进行结构上的改变的操作时，有可能会产生fail-fast机制，这个时候就会抛出ConcurrentModificationException。\n' +
        '\n' +
        'ConcurrentModificationException，是当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。\n' +
        '\n' +
        '举个例子：\n' +
        '如果在foreach 循环里对某些集合元素进行元素的 remove/add 操作的时候，就会触发fail-fast机制，进而抛出CMException。\n' +
        '如果使用jad工具对编译后的class进行反编译，我们可以发现foreach其实是依赖了while循环和Iterator实现的，通过跟踪代码的异常堆栈我们可以知道，实际抛出异常的原因是因为modCount和expectedModCount进行了比较，如果二者不想等，则抛出CMException。\n' +
        'modCount是ArrayList中的一个成员变量。它表示该集合实际被修改的次数，代码初始化集合之后，该变量值默认为0；\n' +
        'expectedModCount 是 ArrayList中的一个内部类，expectedModCount表示这个迭代器预期该集合被修改的次数。其值随着内部类被创建而初始化。只有通过迭代器对集合进行操作，该值才会改变。\n' +
        '简单总结一下，之所以会抛出CMException异常，是因为我们的代码中使用了增强for循环，而在增强for循环中，集合遍历是通过iterator进行的，但是元素的add/remove却是直接使用的集合类自己的方法。这就导致iterator在遍历的时候，会发现有一个元素在自己不知不觉的情况下就被删除/添加了，就会抛出一个异常，用来提示用户，可能发生了并发修改！\n' +
        ' \n' +
        '为了避免触发fail-fast机制，导致异常，我们可以使用Java中提供的一些采用了fail-safe机制的集合类。\n' +
        ' \n' +
        '这样的集合容器在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。\n' +
        ' \n' +
        'java.util.concurrent包下的容器都是fail-safe的，可以在多线程下并发使用，并发修改。同时也可以在foreach中进行add/remove 。',
            'Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。\n' +
            ' \n' +
            'CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。' +
            'CopyOnWrite容器就是一种读写分离的思想，读和写不同的容器。',

            'Index Condition Pushdown（索引下推） MySQL 5.6引入了索引下推优化，默认开启，使用SET optimizer_switch = ‘index_condition_pushdown=off’;可以将其关闭。官方文档中给的例子和解释如下： people表中（zipcode，lastname，firstname）构成一个索引\n' +
            'SELECT * FROM people WHERE zipcode=’95054′ AND lastname LIKE ‘%etrunia%’ AND address LIKE ‘%Main Street%’;\n' +
            '如果没有使用索引下推技术，则MySQL会通过zipcode=’95054’从存储引擎中查询对应的数据，返回到MySQL服务端，然后MySQL服务端基于lastname LIKE ‘%etrunia%’和address LIKE ‘%Main Street%’来判断数据是否符合条件。 如果使用了索引下推技术，则MYSQL首先会返回符合zipcode=’95054’的索引，然后根据lastname LIKE ‘%etrunia%’和address LIKE ‘%Main Street%’来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。 有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。\n'



        ];
        var index = Math.floor((Math.random() * arr.length));
        $("#question").text(arr[index]);
        $("#answer").text(arr2[index]);
        $("#question-card").removeAttr("style");
        $("#answer-card").attr("style", "display:none")
    }

    function all_question() {
        var arr = [
            'Hash索引和B+树所有有什么区别或者说优劣呢?',
            'B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据,什么是聚簇索引?',
            '非聚簇索引一定会回表查询吗?',
            '索引何时失效',
            '建立索引的时候,都有哪些需要考虑的因素呢?',
            '联合索引是什么?为什么需要注意联合索引中的顺序?',
            '创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?',
            '对MySQL的锁了解吗?',
            '为什么要尽量设定一个主键?',
            '主键使用自增ID还是UUID?',
            'InnoDB和MyISAM有什么区别?',
            'MySQL的binlog有有几种录入格式?分别有什么区别?',
            '超大分页怎么处理?',
            '关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?',
            '横向分表和纵向分表,可以分别举一个适合他们的例子吗?',
            '什么是存储过程？有哪些优缺点？',
            '说一说三个范式',
            'MyBatis中的#和$有什么区别?'
            ,'volatile是什么',
            '请你谈谈JMM',
        'Java并发包了解吗？',
        'CAS你知道吗？',
        'CAS都知道，那乐观锁一定知道了？',
            'Java重载和重写的区别',
            '字符串比较之中“==”和equals()的区别',
            'ArrayList和LinkedList的区别',
            '为什么B+树比B树更适合数据库索引？',
            'B树和B+树特点',
            'Hash索引和B+树所有有什么区别或者说优劣呢?',
            'B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据,什么是聚簇索引?',
            '非聚簇索引一定会回表查询吗?',
            '索引何时失效',
            '建立索引的时候,都有哪些需要考虑的因素呢?',
            '联合索引是什么?为什么需要注意联合索引中的顺序?',
            '创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因?',
            '对MySQL的锁了解吗?',
            '为什么要尽量设定一个主键?',
            '主键使用自增ID还是UUID?',
            'InnoDB和MyISAM有什么区别?',
            'MySQL的binlog有有几种录入格式?分别有什么区别?',
            '超大分页怎么处理?',
            '关心过业务系统里面的sql耗时吗?统计过慢查询吗?对慢查询都怎么优化过?',
            '横向分表和纵向分表,可以分别举一个适合他们的例子吗?',
            '什么是存储过程？有哪些优缺点？',
            '说一说三个范式',
            'MyBatis中的#和$有什么区别?'
             ,'volatile是什么',
            '请你谈谈JMM',
        'Java并发包了解吗？',
        'CAS你知道吗？',
        'CAS都知道，那乐观锁一定知道了？'
        ];
        var arr2 = [
            '首先要知道Hash索引和B+树索引的底层实现原理:\n' +
            ' \n' +
            'hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.\n' +
            ' \n' +
            '那么可以看出他们有以下的不同:\n' +
            ' \n' +
            'hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.\n' +
            '\n' +
            ' 因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询.而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.\n' +
            '\n' +
            'hash索引不支持使用索引进行排序\n' +
            '\n' +
            'hash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测\n' +
            '\n' +
            'hash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.\n' +
            '\n' +
            'hash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差.而B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.\n' +
            '\n' +
            '因此,在大多数情况下,直接选择B+树索引可以获得稳定且较好的查询速度.而不需要使用hash索引.',

            '在B+树的索引中,叶子节点可能存储了当前的key值,也可能存储了当前的key值以及整行的数据,这就是聚簇索引和非聚簇索引. 在InnoDB中,只有主键索引是聚簇索引,如果没有主键,则挑选一个唯一键建立聚簇索引.如果没有唯一键,则隐式的生成一个键来建立聚簇索引.\n' +
            ' \n' +
            '当查询使用聚簇索引时,在对应的叶子节点,可以获取到整行数据,因此不用再次进行回表查询',

            '不一定,这涉及到查询语句所要求的字段是否全部命中了索引,如果全部命中了索引,那么就不必再进行回表查询.\n' +
            ' \n' +
            '举个简单的例子,假设我们在员工表的年龄上建立了索引,那么当进行select age from employee where age < 20的查询时,在索引的叶子节点上,已经包含了age信息,不会再次进行回表查询.',

            '（1）组合索引未使用最左前缀，例如组合索引（A，B），where B=b不会使用索引；\n' +
            '\n' +
            '（2）like未使用最左前缀，where A like \'%China\'；\n' +
            '\n' +
            '（3）搜索一个索引而在另一个索引上做order by，where A=a order by B，只使用A上的索引，因为查询只使用一个索引 ；\n' +
            '\n' +
            '（4）or会使索引失效。如果查询字段相同，也可以使用索引。例如where A=a1 or A=a2（生效），where A=a or B=b（失效）\n' +
            '\n' +
            '（5）如果列类型是字符串，要使用引号。例如where A=\'China\'，否则索引失效（会进行类型转换）；\n' +
            '\n' +
            '（6）在索引列上的操作，函数（upper()等）、or、！=(<>)、not in等；',

            '建立索引的时候一般要考虑到字段的使用频率,经常作为条件进行查询的字段比较适合.如果需要建立联合索引的话,还需要考虑联合索引中的顺序.此外也要考虑其他方面,比如防止过多的所有对表造成太大的压力.这些都和实际的表结构以及查询方式有关.',

            'MySQL可以使用多个字段同时建立一个索引,叫做联合索引.在联合索引中,如果想要命中索引,需要按照建立索引时的字段顺序挨个使用,否则无法命中索引.\n' +
            ' \n' +
            '具体原因为:\n' +
            ' \n' +
            'MySQL使用索引时需要索引有序,假设现在建立了"name,age,school"的联合索引,那么索引的排序为: 先按照name排序,如果name相同,则按照age排序,如果age的值也相等,则按照school进行排序.\n' +
            ' \n' +
            '当进行查询时,此时索引仅仅按照name严格有序,因此必须首先使用name字段进行等值查询,之后对于匹配到的列而言,其按照age字段严格有序,此时可以使用age字段用做索引查找,,,以此类推.因此在建立联合索引的时候应该注意索引列的顺序,一般情况下,将查询需求频繁或者字段选择性高的列放在前面.此外可以根据特例的查询或者表结构进行单独的调整.',

            'MySQL提供了explain命令来查看语句的执行计划,MySQL在执行某个语句之前,会将该语句过一遍查询优化器,之后会拿到对语句的分析,也就是执行计划,其中包含了许多信息. 可以通过其中和索引有关的信息来分析是否命中了索引,例如possilbe_key,key,key_len等字段,分别说明了此语句可能会使用的索引,实际使用的索引以及使用的索引长度.',

            '当数据库有并发事务的时候,可能会产生数据的不一致,这时候需要一些机制来保证访问的次序,锁机制就是这样的一个机制.\n' +
            ' \n' +
            '就像酒店的房间,如果大家随意进出,就会出现多人抢夺同一个房间的情况,而在房间上装上锁,申请到钥匙的人才可以入住并且将房间锁起来,其他人只有等他使用完毕才可以再次使用.\n' +
            ' \n' +
            '共享锁: 又叫做读锁. 当用户要进行数据的读取时,对数据加上共享锁.共享锁可以同时加上多个.\n' +
            ' \n' +
            '排他锁: 又叫做写锁. 当用户要进行数据的写入时,对数据加上排他锁.排他锁只可以加一个,他和其他的排他锁,共享锁都相斥.\n' +
            ' \n' +
            '用上面的例子来说就是用户的行为有两种,一种是来看房,多个用户一起看房是可以接受的. 一种是真正的入住一晚,在这期间,无论是想入住的还是想看房的都不可以.\n' +
            ' \n' +
            '锁的粒度取决于具体的存储引擎,InnoDB实现了行级锁,页级锁,表级锁.\n' +
            ' \n' +
            '他们的加锁开销从大大小,并发能力也是从大到小.',

            '主键是数据库确保数据行在整张表唯一性的保障,即使业务上本张表没有主键,也建议添加一个自增长的ID列作为主键.设定了主键之后,在后续的删改查的时候可能更加快速以及确保操作数据范围安全.',

            '推荐使用自增ID,不要使用UUID.\n' +
            ' \n' +
            '因为在InnoDB存储引擎中,主键索引是作为聚簇索引存在的,也就是说,主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序),如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降.\n' +
            ' \n' +
            '总之,在数据量大一些的情况下,用自增主键性能会好一些.\n' +
            ' \n' +
            '《高性能MySQL》: 其中默认后缀为使用自增ID,_uuid为使用UUID为主键的测试,测试了插入100w行和300w行的性能.发现使用自增id的性能远优于UUID\n' +
            ' \n' +
            ' \n' +
            '关于主键是聚簇索引,如果没有主键,InnoDB会选择一个唯一键来作为聚簇索引,如果没有唯一键,会生成一个隐式的主键.',

            'InnoDB支持事物，而MyISAM不支持事物\n' +
            ' \n' +
            'InnoDB支持行级锁，而MyISAM支持表级锁\n' +
            ' \n' +
            'InnoDB支持MVCC, 而MyISAM不支持\n' +
            ' \n' +
            'InnoDB支持外键，而MyISAM不支持\n' +
            ' \n' +
            'InnoDB不支持全文索引，而MyISAM支持。',

            '有三种格式,statement,row和mixed.\n' +
            ' \n' +
            'statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.\n' +
            ' \n' +
            'row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table),因此这种模式的文件保存的信息太多,日志量太大.\n' +
            ' \n' +
            'mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.\n' +
            ' \n' +
            '此外,新版的MySQL中对row级别也做了一些优化,当表结构发生变化的时候,会记录语句而不是逐行记录.',

            '超大的分页一般从两个方向上来解决.\n' +
            ' \n' +
            '数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age > 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age > 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id > 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.\n' +
            ' \n' +
            '从需求的角度减少这种请求....主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.\n' +
            '解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.\n' +
            ' \n' +
            '在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.',

            '在业务系统中,除了使用主键进行的查询,其他的我都会在测试库上测试其耗时,慢查询的统计主要由运维在做,会定期将业务中的慢查询反馈给我们.\n' +
            ' \n' +
            '慢查询的优化首先要搞明白慢的原因是什么? 是查询条件没有命中索引?是load了不需要的数据列?还是数据量太大?\n' +
            ' \n' +
            '所以优化也是针对这三个方向来的,\n' +
            ' \n' +
            ' \n' +
            '首先分析语句,看看是否load了额外的数据,可能是查询了多余的行并且抛弃掉了,可能是加载了许多结果中并不需要的列,对语句进行分析以及重写.\n' +
            '\n' +
            '\n' +
            '分析语句的执行计划,然后获得其使用索引的情况,之后修改语句或者修改索引,使得语句可以尽可能的命中索引.\n' +
            ' \n' +
            '如果对语句的优化已经无法进行,可以考虑表中的数据量是否太大,如果是的话可以进行横向或者纵向的分表.',

            '横向分表是按行分表.假设我们有一张用户表,主键是自增ID且同时是用户的ID.数据量较大,有1亿多条,那么此时放在一张表里的查询效果就不太理想.我们可以根据主键ID进行分表,无论是按尾号分,或者按ID的区间分都是可以的. 假设按照尾号0-99分为100个表,那么每张表中的数据就仅有100w.这时的查询效率无疑是可以满足要求的.\n' +
            ' \n' +
            '纵向分表是按列分表.假设我们现在有一张文章表.包含字段id-摘要-内容.而系统中的展示形式是刷新出一个列表,列表中仅包含标题和摘要,当用户点击某篇文章进入详情时才需要正文内容.此时,如果数据量大,将内容这个很大且不经常使用的列放在一起会拖慢原表的查询速度.我们可以将上面的表分为两张.id-摘要,id-内容.当用户点击详情,那主键再来取一次内容即可.而增加的存储量只是很小的主键字段.代价很小.\n' +
            ' \n' +
            '当然,分表其实和业务的关联度很高,在分表之前一定要做好调研以及benchmark.不要按照自己的猜想盲目操作.',

            '存储过程是一些预编译的SQL语句。 1、更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。 2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全\n' +
            ' \n' +
            '但是,在互联网项目中,其实是不太推荐存储过程的,比较出名的就是阿里的《Java开发手册》中禁止使用存储过程,我个人的理解是,在互联网项目中,迭代太快,项目的生命周期也比较短,人员流动相比于传统的项目也更加频繁,在这样的情况下,存储过程的管理确实是没有那么方便,同时,复用性也没有写在服务层那么好.',
            '第一范式: 每个列都不可以再拆分. 第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分. 第三范式: 非主键列只依赖于主键,不依赖于其他非主键.\n' +
            ' \n' +
            '在设计数据库结构的时候,要尽量遵守三范式,如果不遵守,必须有足够的理由.比如性能. 事实上我们经常会为了性能而妥协数据库的设计.',

            '乱入了一个奇怪的问题.....我只是想单独记录一下这个问题,因为出现频率太高了.\n' +
            ' \n' +
            '# 会将传入的内容当做字符串,而$会直接将传入值拼接在sql语句中.\n' +
            ' \n' +
            '所以#可以在一定程度上预防sql注入攻击.',
            'volatile通常被比喻成”轻量级的synchronized“，也是Java并发编程中比较重要的一个关键字。和synchronized不同，volatile是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。\n' +
        'volatile的用法比较简单，只需要在声明一个可能被多线程同时访问的变量时，使用volatile修饰就可以了。\n' +
        '\n' +
        'volatile的原理\n' +
        '为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。\n' +
        '但是，对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。\n' +
        '但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议\n' +
        '缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。\n' +
        '所以，如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。\n' +
        'volatile与可见性\n' +
        '可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n' +
        'Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。\n' +
        '前面的关于volatile的原理中介绍过了，Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。\n' +
        'volatile与有序性\n' +
        '有序性即程序执行的顺序按照代码的先后顺序执行。除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load->add->save 有可能被优化成load->save->add 。这就是可能存在有序性问题。\n' +
        '而volatile除了可以保证数据的可见性之外，还有一个强大的功能，那就是他可以禁止指令重排优化等。\n' +
        '普通的变量仅仅会保证在该方法的执行过程中所依赖的赋值结果的地方都能获得正确的结果，而不能保证变量的赋值操作的顺序与程序代码中的执行顺序一致。\n' +
        'volatile可以禁止指令重排，这就保证了代码的程序会严格按照代码的先后顺序执行。这就保证了有序性。被volatile修饰的变量的操作，会严格按照代码顺序执行，load->add->save 的执行顺序就是：load、add、save。\n' +
        'volatile与原子性\n' +
        '原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。\n' +
        '线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。\n' +
        '为了保证原子性，需要通过字节码指令monitorenter和monitorexit，但是volatile和这两个指令之间是没有任何关系的。\n' +
        '所以，volatile是不能保证原子性的。\n' +
        '在以下两个场景中可以使用volatile来代替synchronized：\n' +
        '1、运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值。\n' +
        '2、变量不需要与其他状态变量共同参与不变约束。\n' +
        '除以上场景外，都需要使用其他方式来保证原子性，如synchronized或者concurrent包。',

        '【JMM定义】\n' +
        'Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。\n' +
        'Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。\n' +
        '而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。所以，再来总结下，JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。\n' +
        '\n' +
        'JMM具有三大特性\n' +
        '【JMM与有序性】\n' +
        '在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别。\n' +
        'volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。\n' +
        '\n' +
        '【JMM与原子性】\n' +
        'Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。\n' +
        '因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。\n' +
        '\n' +
        '【JMM与可见性】\n' +
        '它的可见性是指当一个线程修改了共享变量的值，其他线程可以立马得知这个修改。\n' +
        'JMM是通过在变量修改之后将新值同步回主内存，在变量读取前从主内存刷新来实现可见性的。JMM的内部实现通常是依赖于内存屏障，通过禁止某些重排序方式，提供内存可见性的保证，也就是实现了各种happen-before的规则。与此同时，更多复杂实现在于编译器和各种体系结构的处理器提供的一致性的行为。\n' +
        '主要有三种实现可见性的方式：\n' +
        '1，volatile：强制将该变量自己和当时其他变量的状态刷出缓存\n' +
        '2，synchronized：进行unlock操作前，必须将变量值同步到主内存\n' +
        '3，final：被final关键字修饰的字段，一旦在构造器中初始化完成，并且没有发生this逃逸（其他线程通过this访问到初始化一半的变量），那么其他线程就能看到被final关键字段修饰的变量',

        'java.util.concurrent包(J.U.C)中包含的是java并发编程中有用的一些工具类，包括几个部分： \n' +
        '1、locks部分：包含在java.util.concurrent.locks包中，提供显式锁(互斥锁和速写锁)相关功能；\n' +
        '2、atomic部分：包含在java.util.concurrent.atomic包中，提供原子变量类相关的功能，是构建非阻塞算法的基础；\n' +
        '3、executor部分：散落在java.util.concurrent包中，提供线程池相关的功能； \n' +
        '4、collections部分：散落在java.util.concurrent包中，提供并发容器相关功能；\n' +
        '5、tools部分：散落在java.util.concurrent包中，提供同步工具类，如信号量、闭锁、栅栏等功能；',

        'CAS是一条CPU并发原语，体现在JAVA的sun.misc.Unsafe类中的各个方法，Unsafe是CAS的核心类，由于Java无法访问底层系统，所以需要通过本地的（native）方法来访问，Unsafe就是相当于一个后门，基于该类可以操作内存特定的数据。说回CAS，CAS其实就是一种比较并且交换的机制，CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的。',

        '乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。\n' +
        ' \n' +
        '相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。\n' +
        ' \n' +
        '实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。',
            '     首先，重载和重写都是多态的一种体现方式。\n' +
            '重载是编译期间的活动，重写是运行期间的活动。\n' +
            '     其次，重载是在一个类中定义相同的名字的方法，方法的参数列表或者类型要互相不同，但是返回值类型不作为是否重载的标准，可以修改可见性；\n' +
            '     重写是不同的，要求子类重写基类的方法时要与父类方法具有相同的参数类型和返回值，可见性需要大于等于基类的方法   \n' +
            ' \n' +
            '关于可见性：\n' +
            '     子类重写父类方法，返回值为基本类型时，必须相同；返回值为引用类型时，要小于等于父类。 \n' +
            '     同理，子类抛出的异常也要小于等于父类； 子类重写方法的修饰词要大于等于父类； 两小、一大、一同原则。',

            ' ==：比较的是两个字符串内存地址（堆内存）的是否相等，属于数值比较；\n' +
            ' equals()：比较的是两个字符串的内容，属于内容比较。',

            '1,ArrayList是实现了基于动态数组的数据结构，而LinkedList是基于链表的数据结构；\n' +
            '2,对于随机访问get和set，ArrayList要优于LinkedList，因为LinkedList要移动指针；\n' +
            '3,对于添加和删除操作add和remove，一般大家都会说LinkedList要比ArrayList快，因为ArrayList要移动数据。但是实际情况并非这样，对于添加或删除，LinkedList和ArrayList并不能明确说明谁快谁慢。\n' +
            '\n' +
            '      从源码可以看出，ArrayList想要get(int index)元素时，直接返回index位置上的元素，而LinkedList需要通过for循环进行查找，虽然LinkedList已经在查找方法上做了优化，比如index < size / 2，则从左边开始查找，反之从右边开始查找，但是还是比ArrayList要慢。这点是毋庸置疑的。\n' +
            '      ArrayList想要在指定位置插入或删除元素时，主要耗时的是System.arraycopy动作，会移动index后面所有的元素；LinkedList主耗时的是要先通过for循环找到index，然后直接插入或删除。这就导致了两者并非一定谁快谁慢，下面通过一个测试程序来测试一下两者插入的速度：\n' +
            '      主要有两个因素决定他们的效率，插入的数据量和插入的位置。我们可以在程序里改变这两个因素来测试它们的效率。\n' +
            '       当数据量较小时，测试程序中，大约小于30的时候，两者效率差不多，没有显著区别；当数据量较大时，大约在容量的1/10处开始，LinkedList的效率就开始没有ArrayList效率高了，特别到一半以及后半的位置插入时，LinkedList效率明显要低于ArrayList，而且数据量越大，越明显。\n' +
            '        所以当插入的数据量很小时，两者区别不太大，当插入的数据量大时，大约在容量的1/10之前，LinkedList会优于ArrayList，在其后就劣与ArrayList，且越靠近后面越差。所以个人觉得，一般首选用ArrayList，由于LinkedList可以实现栈、队列以及双端队列等数据结构，所以当特定需要时候，使用LinkedList，当然咯，数据量小的时候，两者差不多，视具体情况去选择使用；当数据量大的时候，如果只需要在靠前的部分插入或删除数据，那也可以选用LinkedList，反之选择ArrayList反而效率更高。',

            '1、 B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。\n' +
            '\n' +
            '2、B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。\n' +
            '\n' +
            '3、由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。\n' +
            '\n' +
            '我在Stack Overflow上看到有人是这样说的,我感觉说的也挺有道理的，翻译过来大概是这样的：\n' +
            '\n' +
            '他们认为数据库索引采用B+树的主要原因是：B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。',

            'B-TREE树特点\n' +
            '1，根节点至少包含两个孩子\n' +
            '2，树中每个节点至少有m个孩子（m>=2）\n' +
            '3，除根节点和叶节点外，每个节点至少有ceil（m/2）个孩子\n' +
            '4，所有叶子节点位于同一层\n' +
            '5，所有节点关键字是按递增次序排列，并遵循左小右大原则\n' +
            '\n' +
            'B+树基本和B树相同 除了\n' +
            '1，非叶子节点的子树指针与关键字个数相同\n' +
            '2，非叶子节点的子树指针P[i] 指向关键字值[k[i], k[i+1])的子树\n' +
            '3，非叶子节点仅用来索引，数据都保存在叶子节点中\n' +
            '4，所有的叶子节点均有一个链接指向下一个叶子节点',
             '首先要知道Hash索引和B+树索引的底层实现原理:\n' +
            ' \n' +
            'hash索引底层就是hash表,进行查找时,调用一次hash函数就可以获取到相应的键值,之后进行回表查询获得实际数据.B+树底层实现是多路平衡查找树.对于每一次的查询都是从根节点出发,查找到叶子节点方可以获得所查键值,然后根据查询判断是否需要回表查询数据.\n' +
            ' \n' +
            '那么可以看出他们有以下的不同:\n' +
            ' \n' +
            'hash索引进行等值查询更快(一般情况下),但是却无法进行范围查询.\n' +
            '\n' +
            ' 因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询.而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.\n' +
            '\n' +
            'hash索引不支持使用索引进行排序\n' +
            '\n' +
            'hash索引不支持模糊查询以及多列索引的最左前缀匹配.原理也是因为hash函数的不可预测\n' +
            '\n' +
            'hash索引任何时候都避免不了回表查询数据,而B+树在符合某些条件(聚簇索引,覆盖索引等)的时候可以只通过索引完成查询.\n' +
            '\n' +
            'hash索引虽然在等值查询上较快,但是不稳定.性能不可预测,当某个键值存在大量重复的时候,发生hash碰撞,此时效率可能极差.而B+树的查询效率比较稳定,对于所有的查询都是从根节点到叶子节点,且树的高度较低.\n' +
            '\n' +
            '因此,在大多数情况下,直接选择B+树索引可以获得稳定且较好的查询速度.而不需要使用hash索引.',

            '在B+树的索引中,叶子节点可能存储了当前的key值,也可能存储了当前的key值以及整行的数据,这就是聚簇索引和非聚簇索引. 在InnoDB中,只有主键索引是聚簇索引,如果没有主键,则挑选一个唯一键建立聚簇索引.如果没有唯一键,则隐式的生成一个键来建立聚簇索引.\n' +
            ' \n' +
            '当查询使用聚簇索引时,在对应的叶子节点,可以获取到整行数据,因此不用再次进行回表查询',

            '不一定,这涉及到查询语句所要求的字段是否全部命中了索引,如果全部命中了索引,那么就不必再进行回表查询.\n' +
            ' \n' +
            '举个简单的例子,假设我们在员工表的年龄上建立了索引,那么当进行select age from employee where age < 20的查询时,在索引的叶子节点上,已经包含了age信息,不会再次进行回表查询.',

            '（1）组合索引未使用最左前缀，例如组合索引（A，B），where B=b不会使用索引；\n' +
            '\n' +
            '（2）like未使用最左前缀，where A like \'%China\'；\n' +
            '\n' +
            '（3）搜索一个索引而在另一个索引上做order by，where A=a order by B，只使用A上的索引，因为查询只使用一个索引 ；\n' +
            '\n' +
            '（4）or会使索引失效。如果查询字段相同，也可以使用索引。例如where A=a1 or A=a2（生效），where A=a or B=b（失效）\n' +
            '\n' +
            '（5）如果列类型是字符串，要使用引号。例如where A=\'China\'，否则索引失效（会进行类型转换）；\n' +
            '\n' +
            '（6）在索引列上的操作，函数（upper()等）、or、！=(<>)、not in等；',

            '建立索引的时候一般要考虑到字段的使用频率,经常作为条件进行查询的字段比较适合.如果需要建立联合索引的话,还需要考虑联合索引中的顺序.此外也要考虑其他方面,比如防止过多的所有对表造成太大的压力.这些都和实际的表结构以及查询方式有关.',

            'MySQL可以使用多个字段同时建立一个索引,叫做联合索引.在联合索引中,如果想要命中索引,需要按照建立索引时的字段顺序挨个使用,否则无法命中索引.\n' +
            ' \n' +
            '具体原因为:\n' +
            ' \n' +
            'MySQL使用索引时需要索引有序,假设现在建立了"name,age,school"的联合索引,那么索引的排序为: 先按照name排序,如果name相同,则按照age排序,如果age的值也相等,则按照school进行排序.\n' +
            ' \n' +
            '当进行查询时,此时索引仅仅按照name严格有序,因此必须首先使用name字段进行等值查询,之后对于匹配到的列而言,其按照age字段严格有序,此时可以使用age字段用做索引查找,,,以此类推.因此在建立联合索引的时候应该注意索引列的顺序,一般情况下,将查询需求频繁或者字段选择性高的列放在前面.此外可以根据特例的查询或者表结构进行单独的调整.',

            'MySQL提供了explain命令来查看语句的执行计划,MySQL在执行某个语句之前,会将该语句过一遍查询优化器,之后会拿到对语句的分析,也就是执行计划,其中包含了许多信息. 可以通过其中和索引有关的信息来分析是否命中了索引,例如possilbe_key,key,key_len等字段,分别说明了此语句可能会使用的索引,实际使用的索引以及使用的索引长度.',

            '当数据库有并发事务的时候,可能会产生数据的不一致,这时候需要一些机制来保证访问的次序,锁机制就是这样的一个机制.\n' +
            ' \n' +
            '就像酒店的房间,如果大家随意进出,就会出现多人抢夺同一个房间的情况,而在房间上装上锁,申请到钥匙的人才可以入住并且将房间锁起来,其他人只有等他使用完毕才可以再次使用.\n' +
            ' \n' +
            '共享锁: 又叫做读锁. 当用户要进行数据的读取时,对数据加上共享锁.共享锁可以同时加上多个.\n' +
            ' \n' +
            '排他锁: 又叫做写锁. 当用户要进行数据的写入时,对数据加上排他锁.排他锁只可以加一个,他和其他的排他锁,共享锁都相斥.\n' +
            ' \n' +
            '用上面的例子来说就是用户的行为有两种,一种是来看房,多个用户一起看房是可以接受的. 一种是真正的入住一晚,在这期间,无论是想入住的还是想看房的都不可以.\n' +
            ' \n' +
            '锁的粒度取决于具体的存储引擎,InnoDB实现了行级锁,页级锁,表级锁.\n' +
            ' \n' +
            '他们的加锁开销从大大小,并发能力也是从大到小.',

            '主键是数据库确保数据行在整张表唯一性的保障,即使业务上本张表没有主键,也建议添加一个自增长的ID列作为主键.设定了主键之后,在后续的删改查的时候可能更加快速以及确保操作数据范围安全.',

            '推荐使用自增ID,不要使用UUID.\n' +
            ' \n' +
            '因为在InnoDB存储引擎中,主键索引是作为聚簇索引存在的,也就是说,主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序),如果主键索引是自增ID,那么只需要不断向后排列即可,如果是UUID,由于到来的ID与原来的大小不确定,会造成非常多的数据插入,数据移动,然后导致产生很多的内存碎片,进而造成插入性能的下降.\n' +
            ' \n' +
            '总之,在数据量大一些的情况下,用自增主键性能会好一些.\n' +
            ' \n' +
            '《高性能MySQL》: 其中默认后缀为使用自增ID,_uuid为使用UUID为主键的测试,测试了插入100w行和300w行的性能.发现使用自增id的性能远优于UUID\n' +
            ' \n' +
            ' \n' +
            '关于主键是聚簇索引,如果没有主键,InnoDB会选择一个唯一键来作为聚簇索引,如果没有唯一键,会生成一个隐式的主键.',

            'InnoDB支持事物，而MyISAM不支持事物\n' +
            ' \n' +
            'InnoDB支持行级锁，而MyISAM支持表级锁\n' +
            ' \n' +
            'InnoDB支持MVCC, 而MyISAM不支持\n' +
            ' \n' +
            'InnoDB支持外键，而MyISAM不支持\n' +
            ' \n' +
            'InnoDB不支持全文索引，而MyISAM支持。',

            '有三种格式,statement,row和mixed.\n' +
            ' \n' +
            'statement模式下,记录单元为语句.即每一个sql造成的影响会记录.由于sql的执行是有上下文的,因此在保存的时候需要保存相关的信息,同时还有一些使用了函数之类的语句无法被记录复制.\n' +
            ' \n' +
            'row级别下,记录单元为每一行的改动,基本是可以全部记下来但是由于很多操作,会导致大量行的改动(比如alter table),因此这种模式的文件保存的信息太多,日志量太大.\n' +
            ' \n' +
            'mixed. 一种折中的方案,普通操作使用statement记录,当无法使用statement的时候使用row.\n' +
            ' \n' +
            '此外,新版的MySQL中对row级别也做了一些优化,当表结构发生变化的时候,会记录语句而不是逐行记录.',

            '超大的分页一般从两个方向上来解决.\n' +
            ' \n' +
            '数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age > 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age > 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id > 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.\n' +
            ' \n' +
            '从需求的角度减少这种请求....主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.\n' +
            '解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.\n' +
            ' \n' +
            '在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.',

            '在业务系统中,除了使用主键进行的查询,其他的我都会在测试库上测试其耗时,慢查询的统计主要由运维在做,会定期将业务中的慢查询反馈给我们.\n' +
            ' \n' +
            '慢查询的优化首先要搞明白慢的原因是什么? 是查询条件没有命中索引?是load了不需要的数据列?还是数据量太大?\n' +
            ' \n' +
            '所以优化也是针对这三个方向来的,\n' +
            ' \n' +
            ' \n' +
            '首先分析语句,看看是否load了额外的数据,可能是查询了多余的行并且抛弃掉了,可能是加载了许多结果中并不需要的列,对语句进行分析以及重写.\n' +
            '\n' +
            '\n' +
            '分析语句的执行计划,然后获得其使用索引的情况,之后修改语句或者修改索引,使得语句可以尽可能的命中索引.\n' +
            ' \n' +
            '如果对语句的优化已经无法进行,可以考虑表中的数据量是否太大,如果是的话可以进行横向或者纵向的分表.',

            '横向分表是按行分表.假设我们有一张用户表,主键是自增ID且同时是用户的ID.数据量较大,有1亿多条,那么此时放在一张表里的查询效果就不太理想.我们可以根据主键ID进行分表,无论是按尾号分,或者按ID的区间分都是可以的. 假设按照尾号0-99分为100个表,那么每张表中的数据就仅有100w.这时的查询效率无疑是可以满足要求的.\n' +
            ' \n' +
            '纵向分表是按列分表.假设我们现在有一张文章表.包含字段id-摘要-内容.而系统中的展示形式是刷新出一个列表,列表中仅包含标题和摘要,当用户点击某篇文章进入详情时才需要正文内容.此时,如果数据量大,将内容这个很大且不经常使用的列放在一起会拖慢原表的查询速度.我们可以将上面的表分为两张.id-摘要,id-内容.当用户点击详情,那主键再来取一次内容即可.而增加的存储量只是很小的主键字段.代价很小.\n' +
            ' \n' +
            '当然,分表其实和业务的关联度很高,在分表之前一定要做好调研以及benchmark.不要按照自己的猜想盲目操作.',

            '存储过程是一些预编译的SQL语句。 1、更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。 2、存储过程是一个预编译的代码块，执行效率比较高,一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率,可以一定程度上确保数据安全\n' +
            ' \n' +
            '但是,在互联网项目中,其实是不太推荐存储过程的,比较出名的就是阿里的《Java开发手册》中禁止使用存储过程,我个人的理解是,在互联网项目中,迭代太快,项目的生命周期也比较短,人员流动相比于传统的项目也更加频繁,在这样的情况下,存储过程的管理确实是没有那么方便,同时,复用性也没有写在服务层那么好.',
            '第一范式: 每个列都不可以再拆分. 第二范式: 非主键列完全依赖于主键,而不能是依赖于主键的一部分. 第三范式: 非主键列只依赖于主键,不依赖于其他非主键.\n' +
            ' \n' +
            '在设计数据库结构的时候,要尽量遵守三范式,如果不遵守,必须有足够的理由.比如性能. 事实上我们经常会为了性能而妥协数据库的设计.',

            '乱入了一个奇怪的问题.....我只是想单独记录一下这个问题,因为出现频率太高了.\n' +
            ' \n' +
            '# 会将传入的内容当做字符串,而$会直接将传入值拼接在sql语句中.\n' +
            ' \n' +
            '所以#可以在一定程度上预防sql注入攻击.',

            'volatile通常被比喻成”轻量级的synchronized“，也是Java并发编程中比较重要的一个关键字。和synchronized不同，volatile是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。\n' +
        'volatile的用法比较简单，只需要在声明一个可能被多线程同时访问的变量时，使用volatile修饰就可以了。\n' +
        '\n' +
        'volatile的原理\n' +
        '为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。\n' +
        '但是，对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。\n' +
        '但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议\n' +
        '缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。\n' +
        '所以，如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。\n' +
        'volatile与可见性\n' +
        '可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。\n' +
        'Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。\n' +
        '前面的关于volatile的原理中介绍过了，Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。\n' +
        'volatile与有序性\n' +
        '有序性即程序执行的顺序按照代码的先后顺序执行。除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load->add->save 有可能被优化成load->save->add 。这就是可能存在有序性问题。\n' +
        '而volatile除了可以保证数据的可见性之外，还有一个强大的功能，那就是他可以禁止指令重排优化等。\n' +
        '普通的变量仅仅会保证在该方法的执行过程中所依赖的赋值结果的地方都能获得正确的结果，而不能保证变量的赋值操作的顺序与程序代码中的执行顺序一致。\n' +
        'volatile可以禁止指令重排，这就保证了代码的程序会严格按照代码的先后顺序执行。这就保证了有序性。被volatile修饰的变量的操作，会严格按照代码顺序执行，load->add->save 的执行顺序就是：load、add、save。\n' +
        'volatile与原子性\n' +
        '原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。\n' +
        '线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。\n' +
        '为了保证原子性，需要通过字节码指令monitorenter和monitorexit，但是volatile和这两个指令之间是没有任何关系的。\n' +
        '所以，volatile是不能保证原子性的。\n' +
        '在以下两个场景中可以使用volatile来代替synchronized：\n' +
        '1、运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值。\n' +
        '2、变量不需要与其他状态变量共同参与不变约束。\n' +
        '除以上场景外，都需要使用其他方式来保证原子性，如synchronized或者concurrent包。',

        '【JMM定义】\n' +
        'Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。\n' +
        'Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。\n' +
        '而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。所以，再来总结下，JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。\n' +
        '\n' +
        'JMM具有三大特性\n' +
        '【JMM与有序性】\n' +
        '在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别。\n' +
        'volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。\n' +
        '\n' +
        '【JMM与原子性】\n' +
        'Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。\n' +
        '因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。\n' +
        '\n' +
        '【JMM与可见性】\n' +
        '它的可见性是指当一个线程修改了共享变量的值，其他线程可以立马得知这个修改。\n' +
        'JMM是通过在变量修改之后将新值同步回主内存，在变量读取前从主内存刷新来实现可见性的。JMM的内部实现通常是依赖于内存屏障，通过禁止某些重排序方式，提供内存可见性的保证，也就是实现了各种happen-before的规则。与此同时，更多复杂实现在于编译器和各种体系结构的处理器提供的一致性的行为。\n' +
        '主要有三种实现可见性的方式：\n' +
        '1，volatile：强制将该变量自己和当时其他变量的状态刷出缓存\n' +
        '2，synchronized：进行unlock操作前，必须将变量值同步到主内存\n' +
        '3，final：被final关键字修饰的字段，一旦在构造器中初始化完成，并且没有发生this逃逸（其他线程通过this访问到初始化一半的变量），那么其他线程就能看到被final关键字段修饰的变量',

        'java.util.concurrent包(J.U.C)中包含的是java并发编程中有用的一些工具类，包括几个部分： \n' +
        '1、locks部分：包含在java.util.concurrent.locks包中，提供显式锁(互斥锁和速写锁)相关功能；\n' +
        '2、atomic部分：包含在java.util.concurrent.atomic包中，提供原子变量类相关的功能，是构建非阻塞算法的基础；\n' +
        '3、executor部分：散落在java.util.concurrent包中，提供线程池相关的功能； \n' +
        '4、collections部分：散落在java.util.concurrent包中，提供并发容器相关功能；\n' +
        '5、tools部分：散落在java.util.concurrent包中，提供同步工具类，如信号量、闭锁、栅栏等功能；',

        'CAS是一条CPU并发原语，体现在JAVA的sun.misc.Unsafe类中的各个方法，Unsafe是CAS的核心类，由于Java无法访问底层系统，所以需要通过本地的（native）方法来访问，Unsafe就是相当于一个后门，基于该类可以操作内存特定的数据。说回CAS，CAS其实就是一种比较并且交换的机制，CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在 CAS 的一些特殊情况下将仅返回 CAS 是否成功，而不提取当前值。）CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的。',

        '乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。\n' +
        ' \n' +
        '相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。\n' +
        ' \n' +
        '实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。'
        ];
        var index = Math.floor((Math.random() * arr.length));
        $("#question").text(arr[index]);
        $("#answer").text(arr2[index]);
        $("#question-card").removeAttr("style");
        $("#answer-card").attr("style", "display:none")
    }

    function show_answer() {
        $("#answer-card").removeAttr("style");
    }

    function refersh() {
        today_question();
        $("#answer-card").attr("style", "display:none")
    }

    function questioned() {
        var val = $("#question").text();
        appendText(val);
        refersh();
    }

    function appendText(val) {
        var txt2 = $('<p     style = "border: solid;\n' +
            '    height: 50px;\n' +
            '    /* margin-top: 15px; */\n' +
            '    padding: 16px 0;"\n' +
            '}></p>').text(val);  // 使用 jQuery 创建文本
        $("#un-question").append(txt2);        // 追加新元素
    }

    function changeVal(obj) {
        var index = obj.selectedIndex;
        var rela = obj.children[index];
        if (rela.value === "1") {
            $("#choose-question").attr("onclick", "today_question();")
        }

        if (rela.value === "2") {
            $("#choose-question").attr("onclick", "yesterday_question();")
        }

        if (rela.value === "3") {
            $("#choose-question").attr("onclick", "all_question();")
        }
    }
</script>

<body>
<div class="page-group">
    <div class="page page-current">
        <div class="content">
            <select name="select" onchange="changeVal(this)">
                <option value="1">今天</option>
                <option value="2">昨天</option>
                <option value="3">全部</option>
            </select>
            <div class="content-block-title">问题：</div>
            <p>
                <a id="choose-question" class="button" onclick="today_question();">点击出现问题</a>
            </p>
            <div id="question-card" class="card" style="display: none">
                <div class="card-content">
                    <div id="question" class="card-content-inner"></div>
                </div>
            </div>
            <div class="content-block-title">答案：</div>
            <p>
                <a href="#" class="button" onclick="show_answer();">点击显示答案</a></p>
            <div id="answer-card" class="card" style="display: none">
                <div class="card-content">
                    <textarea cols="70" rows="20" id="answer" class="card-content-inner"></textarea>
                </div>
            </div>
            <div id="un-question" class="content-block-title">不会的问题：</div>
            <div class="row">
                <div class="col-50">
                    <a href="#" class="button button-big button-fill button-danger" onclick="refersh()">会</a></div>
                <div class="col-50">
                    <a href="#" class="button button-big button-fill button-success" onclick="questioned()">不会</a></div>
            </div>
        </div>
    </div>
    <script type='text/javascript' src='//g.alicdn.com/sj/lib/zepto/zepto.min.js' charset='utf-8'></script>
    <script type='text/javascript' src='//g.alicdn.com/msui/sm/0.6.2/js/sm.min.js' charset='utf-8'></script>
    <script type='text/javascript' src='//g.alicdn.com/msui/sm/0.6.2/js/sm-extend.min.js' charset='utf-8'></script>
</div>
</body>

</html>